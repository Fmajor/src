;; Define places
(defparameter *nodes* '((gate (you pass an old iron gate.))
		       (lobby (you are in an dark and dirty "lobby," seems not cleaned for long time.))
			(bathroom (you are in an small bathroom. The water pipe is broken. It seems something moving very fast and hide when you come in.))
			(kitchen (you are in kitchen.))
			(living-room (you are in a living-room with many toys on "bed," seems to be a "girl's" living-room.))
			(garden (you are in a garden with lots of weeds.))
			(street (you are at the street.))
			)
  )
;; Define relation
(defparameter *edges* '((gate (lobby front door)
			(street back door))
		       (lobby (gate back  door)
			(living-room right door)
			(kitchen left door)
			(bathroom front door)
			)
		       (bathroom (lobby back door))
		       (kitchen (lobby back door)
			(garden front door)
			)
		       (living-room (lobby back door))
		       (garden (kitchen back door))
		       (street (gate front door))
		       )
  )
;; Define objects
(defparameter *objects* '(lighter camera photo notebook shoe clother knife apple))
;; Define object location
(defparameter *object-locations* '((lighter living-room)
				   (camera lobby)
				   (photo bathroom)
				   (notebook living-room)
				   (shoe gate)
				   (clother bathroom)
				   (knife kitchen)
				   (apple kitchen)
				   )
  )
;; Define initial location
(defparameter *location* 'gate)
;; define descriptions of objects, path, location
(defun describe-location (location nodes)
  (cadr  (assoc location nodes))
  )
(defun describe-path (edge)
  `(there is a ,(caddr edge) in the ,(cadr edge) direction.)
  )
(defun describe-paths (location edges)
  (apply #'append (mapcar #'describe-path (cdr (assoc location edges))))
  )
(defun object-at(location objects object-locations)
  (labels ((is-here-p (object)
		   (eq location (cadr (assoc object object-locations)))
		   ))
    (remove-if-not #'is-here-p objects)
    )
  )
(defun describe-objects (location objects object-locations)
  (append '(You see) (object-at location objects object-locations) '(here))
  )
;;define look for player
(defun look()
  (append  (describe-location *location* *nodes*)
	   (describe-paths *location* *edges*)
	   (describe-objects *location* *objects* *object-locations*))
  )
;;define walk for player
(defun walk(direction)
  (let ((next (find direction (cdr (assoc *location* *edges*)):key #'cadr)))
    (or (and next (setf *location* (car next)) (look)) `(you cannot go that way.))
    )
  )
;;define pick-up for player
(defun pick-up(object)
  (cond ((member object (object-at *location* *objects* *object-locations*)) (push (list object 'body) *object-locations*)
	 `(you are now carrying the ,object))
	(t '(you cannot get that.))
	)
  )
;;define inventory for player
(defun inventory()
  `(items- ,(object-at 'body *objects* *object-locations*))
  )
;;interface to player
(defun game-read()
  (let ((cmd (read-from-string (concatenate 'string "(" (read-line) ")"))))
    (flet ((quote-it (x)
	     (list 'quote x)))
      (cons (car cmd) (mapcar #'quote-it (cdr cmd)))
      )
    )
  )
(defparameter *allowed-commands* '(look walk pick-up inventory))
(defun game-eval(sexp)
  (if (member (car sexp) *allowed-commands*)
      (eval sexp)
      '(i do not know that command.))
  )
(defun tweak-it(lst cap lit)
  (when lst
    (let ((item (car lst))
	  (rest (cdr lst)))
      (cond ((eql item #\space) (cons item (tweak-it rest cap lit)))
	    ((member item '(#\. #\? #\!)) (cons item (tweak-it rest t lit)))
	    ((eql item #\") (tweak-it rest cap (not lit)))
	    (lit (cons item (tweak-it rest nil lit)))
	    (cap (cons (char-upcase item) (tweak-it rest nil lit)))
	  (t (cons (char-downcase item) (tweak-it rest nil nil)))
	  )
      )
    )
  )
(defun game-print(lst)
  (princ (coerce (tweak-it (coerce (string-trim "() " (prin1-to-string lst)) 'list) t nil) 'string))
  (fresh-line)
  )
(defun game-repl()
  (let ((cmd (game-read)))
	(or (eq (car cmd) 'quit) (and (game-print (game-eval cmd)) (game-repl)))))

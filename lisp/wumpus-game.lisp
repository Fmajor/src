;;load graphiz-util.lisp
(load "graphiz-util")

;;basic parameters
(defparameter *city-locations* nil)
(defparameter *city-roads* nil)
(defparameter *visited-nodes* nil)
(defparameter *player-pos* nil)
(defparameter *node-num* 30)
;(defparameter *edge-num* 45)
;(defparameter *worm-num* 3)
;(defparameter *cop-odds* 15)

;;get random node
(defun random-node (node-num)
  (1+ (random node-num))
  )
;;make edge pair
(defun edge-pair(node1 node2)
  (unless (eq node1 node2)
    (list (cons node1 node2) (cons node2 node1)
	 ))
  )
;;make edge list
(defun make-edge-list (edge-num node-num)
  (apply #'append (loop repeat edge-num
     collect (edge-pair (random-node node-num) (random-node node-num))
       ))
  )
;;check isolate nodes
;;Find neighbor edges of node
(defun direct-edges(node edge-list)
;;  (mapcan (lambda(edge-pair)
;;	    (if (eq node (car edge-pair))
;;		edge-pair
;;		nil))
;;	  edge-list)
  (remove-if-not (lambda(x)
		   (eq node (car x)))
		 edge-list)
  )
;;Get all connected nodes from node
(defun get-connected (node edge-list)
  (let ((vis nil))
    (labels ((trace-all (chk)
	       (unless (member chk vis)
		   (push chk vis)
		   (mapc #'trace-all
			 (mapcar #'cdr (direct-edges chk edge-list)))
	;(lambda (edge)
	;(trace-all (cdr edge)))
		   )
	       ))
      (trace-all node)
      )
    vis)
  )
;;Get connected nodes with Hash table
(defun hash-edges (edge-list)
  (let ((tab (make-hash-table)))
    (mapc (lambda (x)
	    (push (cdr x) (gethash (car x) tab)))
	  edge-list)
    tab)
  )
(defun get-connected-hash (node edge-hash)
  (let ((vis (make-hash-table)))
    (labels ((trace-all (chk)
	       (unless (gethash chk vis)
		 (setf (gethash chk vis) t)
		 (mapc #'trace-all
		       (gethash chk edge-hash))
		 )))
      (trace-all node)
      )
    vis)
  )
;;Find isolated islands
(defun find-islands (nodes edge-list)
  (let ((islands nil))
    (labels ((find-land (chk)
			(let* ((connected (get-connected (car chk) edge-list))
			     (unconnected (set-difference chk connected)))
			     (push connected islands)
			     (when unconnected
			       (find-land unconnected)
			       )
			     )))
	    (find-land nodes))
    islands)
  )
;;Connect all islands return bridge edge-pair
(defun connect-with-bridge (islands)
  (if (cdr islands)
      (append (edge-pair (caar islands) (caadr islands)) (connect-with-bridge (cdr islands))))
  )
;;generated new edge-list with all nodes connected
(defun all-connected-edge-list (nodes edge-list)
  (append (connect-with-bridge (find-islands nodes edge-list)) edge-list)
  )
;;transform edges to alist based on nodes
(defun edges-to-alist (nodes edge-list)
  (mapcar (lambda (node1)
	    (cons node1
		  (mapcar (lambda (x)
			    (list (cdr x)))
			  (remove-duplicates (direct-edges node1 edge-list) :test #'equal)))
	    )
	  nodes)
  )
;;add cops
(defun add-cops (edge-alist edge-with-cops)
  (mapcar (lambda (x)
	    (let* ((node1 (car x)))
	      (cons node1 
		    (mapcar (lambda (n2)
			      (let ((node2 (car n2)))
			       (if (intersection (edge-pair node1 node2)
						 edge-with-cops
						 :test #'equal)
				   (list node2 'cops)
				   n2)
			       ))
			    (cdr x)
			    )
		    )
	      )
	    )
	  edge-alist)
  )
;;generate city-edge with alist format
(defun make-city-edges (node-num edge-num cop-odds)
  (let* ((nodes (loop for i from 1 to node-num collect i))
	 (edge-list (all-connected-edge-list nodes (make-edge-list edge-num node-num)))
	 (cops (remove-if-not (lambda(x)
				(zerop (random cop-odds))
				)
			      edge-list)))
    (add-cops (edges-to-alist nodes edge-list) cops)
    )
  )
;;get neighbors of node
(defun neighbors (node edge-alist)
  (mapcar #'car (cdr (assoc node edge-alist)))
  )
;;check wthether node1 & node2 are neighbors
(defun within-one (node1 node2 edge-alist)
  (member node2 (neighbors node1 edge-alist))
  )

;;check wthether node1 & node2 are within two edges
(defun within-two (node1 node2 edge-alist)
  (or (within-one node1 node2 edge-alist)
      (some (lambda (x)
	      (within-one node2 x edge-alist)
	      )
	    (neighbors node1 edge-alist)
	    )
      )
  )
;;generate city nodes
(defun make-city-nodes (node-num edge-alist worm-num)
  (let ((wumpus (random-node node-num))
	(worms (loop for i from 1 to worm-num collect (random-node node-num))))
    (loop for i from 1 to node-num
	 collect (append (list i)
			 (cond ((eql i wumpus) '(wumpus))
			       ((within-two i wumpus edge-alist) '(blood!)))
			 (cond ((member i worms) '(glow-worm))
			       ((some (lambda (j)
					(within-one i j edge-alist)
					)
				      worms)
				'(lights!)))
			 (when (some #'cdr (cdr (assoc i edge-alist)))
			   '(sirens!)))
	 )
    )
  )
;;find empty node for player location
(defun find-empty-node (city-nodes node-num)
  (let ((x (random-node node-num)))
    (if (cdr (assoc x city-nodes))
	(find-empty-node city-nodes node-num)
	x)
    )
  )
;;draw city map
(defun draw-city (nodes edge-alist)
  (ugraph->dot "city.dot" nodes edge-alist)
  )
;;get known city location
(defun known-city-nodes(vis-nodes city-nodes city-edges player-pos)
  (mapcar (lambda (node)
	    (if (member node vis-nodes)
		(let ((node-name (assoc node city-nodes)))
		  (if (eql node player-pos)
		      (append node-name '(*))
		      node-name))
		(list node '?)))
	  (remove-duplicates (append vis-nodes
				     (mapcan (lambda (x)
					       (neighbors x city-edges))
					     vis-nodes)
				     )
			     )
	  )
  )
;;get know city roads
(defun known-city-edges(vis-nodes city-edges)
  (mapcar (lambda (node)
	    (cons node (mapcar (lambda (x)
				 (if (member (car x) vis-nodes)
				     x
				     (list (car x))))
			       (cdr (assoc node city-edges)))
		  ))
	  vis-nodes)
  )
;;draw known city map
(defun draw-known-city (vis-nodes city-nodes city-edges player-pos)
  (ugraph->dot "trace.dot" (known-city-nodes vis-nodes city-nodes city-edges player-pos) (known-city-edges vis-nodes city-edges))
  )
;;game interface new game
(defun new-game(location-num road-num worm-num cop-odds)
  (setf *node-num* location-num)
  (setf *city-roads* (make-city-edges location-num road-num cop-odds))
  (setf *city-locations* (make-city-nodes location-num *city-roads* worm-num))
  (setf *player-pos* (find-empty-node *city-locations* location-num))
  (setf *visited-nodes* (list *player-pos*))
  (draw-city *city-locations* *city-roads*)
  (draw-known-city *visited-nodes* *city-locations* *city-roads* *player-pos*)
  )
;;move to new place
(defun handle-new-place (edge pos charging)
  (let* ((node (assoc pos *city-locations*))
	 (has-worm (and (member 'glow-worm node)
			(not (member pos *visited-nodes*)))))
    (pushnew pos *visited-nodes*)
    (setf *player-pos* pos)
    (draw-known-city *visited-nodes* *city-locations* *city-roads* *player-pos*)
    (cond ((member 'cops edge) (princ "You ran into the cops, Game Over."))
	  ((member 'wumpus node) (if charging
				     (princ "You catch the Wumpus!")
				     (princ "You ran into the Wumpus, Game Over.")))
	  (charging (princ "You wasted your last bullet. Game Over."))
	  (has-worm (let ((new-pos (random-node *node-num*)))
		      (princ "You ran into a Glow Worm Gang! You're now at ")
		      (princ new-pos)
		      (handle-new-place nil new-pos nil))))
    )
  )
(defun handle-direction (pos charging)
  (let ((edge (assoc pos (cdr (assoc *player-pos* *city-roads*)))))
    (if edge
	(handle-new-place edge pos charging)
	(princ "You cannot reach that location.")
	)
    )
  )
;;game interface walk
(defun walk (pos)
  (handle-direction pos nil)
  )
;;game interface charge
(defun charge (pos)
  (handle-direction pos t)
  )
